{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:/Users/Bhavesh/Desktop/Visual Studio/bhavesh_khandar_fw21_0749/unit-4/sprint-4/day-4/assignments/Project/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar utils = require('@motionone/utils');\nvar inset = require('./inset.cjs.js');\nvar presets = require('./presets.cjs.js');\nvar offset = require('./offset.cjs.js');\nvar point = {\n  x: 0,\n  y: 0\n};\nfunction resolveOffsets(container, info, options) {\n  var _options$offset = options.offset,\n    offsetDefinition = _options$offset === void 0 ? presets.ScrollOffset.All : _options$offset;\n  var _options$target = options.target,\n    target = _options$target === void 0 ? container : _options$target,\n    _options$axis = options.axis,\n    axis = _options$axis === void 0 ? \"y\" : _options$axis;\n  var lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  var inset$1 = target !== container ? inset.calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n  var targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n  var containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n  var hasChanged = !info[axis].interpolate;\n  var numOffsets = offsetDefinition.length;\n  for (var i = 0; i < numOffsets; i++) {\n    var offset$1 = offset.resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset$1[axis]);\n    if (!hasChanged && offset$1 !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i] = offset$1;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n  if (hasChanged) {\n    info[axis].interpolate = utils.interpolate(utils.defaultOffset(numOffsets), info[axis].offset);\n    info[axis].interpolatorOffsets = _toConsumableArray(info[axis].offset);\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\nexports.resolveOffsets = resolveOffsets;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils","require","inset","presets","offset","point","x","y","resolveOffsets","container","info","options","offsetDefinition","ScrollOffset","All","target","axis","lengthLabel","inset$1","calcInset","targetSize","width","scrollWidth","height","scrollHeight","clientWidth","clientHeight","containerSize","length","hasChanged","interpolate","numOffsets","i","offset$1","resolveOffset","interpolatorOffsets","defaultOffset","progress","current"],"sources":["C:/Users/Bhavesh/Desktop/Visual Studio/bhavesh_khandar_fw21_0749/unit-4/sprint-4/day-4/assignments/Project/node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.cjs.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('@motionone/utils');\nvar inset = require('./inset.cjs.js');\nvar presets = require('./presets.cjs.js');\nvar offset = require('./offset.cjs.js');\n\nconst point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = presets.ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset$1 = target !== container ? inset.calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : { width: target.clientWidth, height: target.clientHeight };\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset$1 = offset.resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset$1[axis]);\n        if (!hasChanged && offset$1 !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset$1;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = utils.interpolate(utils.defaultOffset(numOffsets), info[axis].offset);\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexports.resolveOffsets = resolveOffsets;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}